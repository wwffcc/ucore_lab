#lab3 Report

## [练习0] 填写已有实验
见文件即可。其中将lab1中的特权级转化注释了。

## [练习1] 未被映射的地址映射上物理页

> 实现参照注释，首先调用get_pte得到一级页表ptep指针，如果发现相应物理地址不存在，那么调用pgdir_alloc_page分配一个页，并且将逻辑地址和物理地址关联起来;否则，如果该地址是交换项，就利用物理地址从disk载入其内容，使用的是swap_in函数，然后用page_insert在页表中插入逻辑地址和物理地址的映射关系，然后用swap_map_swappable使得该页可交换。

[练习1.1] 请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。
> 答：驻留位：表明该表项是否有效，如果无效，就要从内存载入。</br>
保护位：和该项的读写权限有关。</br>
修改位：标示该页表项是否被修改过，如果修改过，在被替换前，要将内容写回内存，以免不一致。</br>
访问位：该位标示此表项是否被访问过，在页面替换算法中可以作为替换的一个指标。</br>

[练习1.2] 如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？
> 答：硬件此时陷入内核，如果缺页服务例程执行时访问内存又出现了页访问异常，就会触发double fault，导致reboot，硬件重新加载操作系统。

## [练习2] 补充完成基于FIFO的页面替换算法

> 实现fifo比较容易。在_fifo_map_swappable中用list_add将新的表项插入队列末端。</br>
在_fifo_swap_out_victim选择牺牲页，按照fifo算法，就是取出队头。由于是双向链表，因此header->prev就是队头元素，取出它，作为替换页。

[练习2.1] 如果要在ucore上实现"extended clock页替换算法"请给你的设计方案，现有的swap_manager框架是否足以支持在ucore中实现此算法？如果是，请给你的设计方案。如果不是，请给出你的新的扩展和基此扩展的设计方案。并需要回答如下问题</br>
> 答：可以支持，因为表项里留了足够的位数，借此可以实现扩展clock算法。</br>
方案：1.在页面中增加访问位，描述页面在过去一段时间的内访问情况;修改位，并在访问时进行相应修改。</br>
2.将页面组织成环形链表。</br>
3.指针指向最先调入的页面。</br>
算法的流程是：页面装入内存时，访问位、修改位初始化为0。访问页面时，访问位置1,如果是写操作，修改位置1。缺页时，从指针当前位置顺序检查环形链表，如果访问位|修改位是00,则替换该页，载入新表项，就置10或11,视是否写而定;是01，则变为00，并将数据写回内存;是10,则变为00;是11,则变为01。</br>

[练习2.1.1] 需要被换出的页的特征是什么？
> 答：访问位是0,同时修改位是0。</br>
[练习2.1.2] 在ucore中如何判断具有这样特征的页？
> 答：每次访问了该页，就将该页的访问位置1,如果是写操作，就将修改位置1。通过访问位和修改位就可以看出。</br>
[练习2.1.3] 何时进行换入和换出操作？
> 答：时钟指针转到访问位为0,修改位为0处，就可以将该页作为替换页，进行换入换出。</br>

## 实验分析
> 参照注释写的，调试不成功时，看了答案的解答，这样才比较快地完成了整个lab3。整个实现是一致的，都是注释的逻辑。

## OS原理知识
> 重要的知识点是：</br>
1.缺页中断处理机制。
2.当没有空闲页时，选择牺牲页的fifo算法。
> 实验中只实现了最简单的fifo算法，而原理中讲了5种页面替换算法。当然，真正实现起来，如果不懂实验中的数据结构，函数，宏，写起来也感觉到吃力。

## 四.列出你认为OS原理中很重要，但在实验中没有对应上的知识点
> 就是各种页面替换算法，实验中只实现了fifo，相对而言简单。如果实现LRU就更好了。还有，原理讲到全局替换算法，但实验只涉及到局部替换算法，这也没对应到。
