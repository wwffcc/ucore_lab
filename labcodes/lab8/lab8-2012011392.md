# lab8 Report

## [练习0] 填写已有实验
> 具体见代码文件。

## [练习1] 完成读文件操作的实现
[练习1.1] 给出设计实现”UNIX的PIPE机制“的概要设方案
> Linux内核中采用struct pipe_inode_info结构体来描述一个管道。
</br>
其中，当pipe为空/满时，采用等待队列，该队列使用自旋锁进行保护。</br>

用struct Pipe_buffer数据结构描述pipe的缓冲（buffer）</br>

以下针对pipe实现中对环形缓冲区的操作方法,因此，着重分析pipe_read和pipe_write方法。</br>
Pipe_read(fs/pipe.c)</br>
访问pipe对应的inode必须获得相应的互斥锁，防止并发访问。</br>

数据的读出放在一个死循环中，整个for循环中的代码均属于临界区，需要互斥锁进行保护。</br>

有以下几种情况才会退出：</br>
(i)     完成数据的读出；</br>
(ii)    Pipe没有writer进程</br>
(iii)   进程设置了O_NONBLOCK标志</br>

将buffer中的数据读出。完成后，紧接着调整buffer中指针的位置</br>

其中，设置标志，do_wakeup为1，说明buffer中已经有空位置可以写入数据，这时，可以唤醒等待队列中的睡眠的写进程。</br>

如果没有退出，或者成功读取数据，读进程会主动调用pipe_wait函数进行睡眠等待，直到有writer进程写入数据并将其唤醒。</br>
  
当进程从临界区中退出后会释放互斥锁。</br>
 

最后，为了防止reader进程是因为收到信号量而退出，再给睡眠的writer进程一次机会，检查do_wakeup，如果为1就唤醒睡眠的writer进程。</br>
pipe_write(fs/pipe.c)</br>
首先，与pipe_read相同，pipe_write采用互斥锁对临界区进行保护。写操作也放在死循环中，退出条件也与read相同。</br>

与pipe_read不同，writer进程不总是睡眠等待，在调用pipe_wait进行睡眠后，如果有read进程读走某些数据，write进程会随时进行写操作
</br>

## [练习2] 完成基于文件系统的执行程序机制的实现
[练习2.1] 给出设计实现基于”UNIX的硬链接和软链接机制“的概要设方案
> 硬链接：
</br>
文件有相同的 inode 及 data block；</br>
只能对已存在的文件进行创建；</br>
不能交叉文件系统进行硬链接的创建；</br>
不能对目录进行创建，只可对文件创建；</br>
删除一个硬链接文件并不影响其他有相同 inode 号的文件。</br>

软链接：</br>
软链接有自己的文件属性及权限等；</br>
可对不存在的文件或目录创建软链接；</br>
软链接可交叉文件系统；</br>
软链接可对文件或目录创建；</br>
创建软链接时，链接计数 i_nlink 不会增加；</br>
删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。</br>

## 实验分析
> 主要参照实验指导书lab8和注释写的，和答案的实现基本一致。

## OS原理知识
> 重要的知识点：文件系统的布局、文件系统抽象层、基本的文件操作。
</br>
原理和实现基本是一致的。

## 列出你认为OS原理中很重要，但在实验中没有对应上的知识点
> 实验中数据块的查找基于索引，而原理中还提出顺序和链表的方式。
