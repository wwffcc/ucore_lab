#Lab2 Report

## 一.练习

### [练习0] 填写已有实验
见文件即可。

### [练习1] 实现first-fit连续物理内存分配算法

>first-fit算法的实现：想法就是记录一个空闲块链表，按空闲块起始物理地址进行排序。对于申请，就从表头依次遍历下去，找到块容量不小于申请大小时，就切分出这段块满足申请，并且把可能留下的富于空间插入链表;至于释放，就要考虑空闲块的合并，而这个，只要把基址加上块大小，进行地址的比对，就可以判断地址是否相邻，以决定能否把碎片合并成大块回收。具体实现：
default_init不用修改，这里free_list是双向链表的头指针，nr_free记录空闲块的数目。主要是default_alloc_pages,和default_free_pages。</br></br>用C语言编程，有一点不好，就是程序可读性太差，我几乎是照着注释写的，尽管知道注释里的做法并不是很好，但是我对空闲块的标志位设置实在是不清楚，什么property，flag，page_link,这样一个个定义的宏，导致我用grep和find搜半天，然后查清，但按自己的想法写就是过不了，只好把答案参考着写。  
> 关于first fit的改进:算法本身其实没有多少可改进的，只是提一点，因为每次释放立即进行块的合并，所以每次合并时，只要左右看看有没有相邻空闲块即可。如果说改进，可以尝试释放了空间后，不立即进行块的合并，这样可以减少合并的频度，尤其对那些申请释放特别频繁的情况;然后在一段时间后再统一进行碎片的处理，比如，发现空间不够申请了，就可以看看合并后，能不能提供想要的块大小。

## [练习2] 实现寻找虚拟地址对应的页表项

> 实现过程：从虚拟地址找到对应页表项，由于是二级页表，首先根据虚拟地址中的字段索引到页目录项，用宏PDX实现，然后在页目录项里，查看有没有页表项，如果没有，就创建一个（通过标志位可见到）;否则仍然是根据虚拟地址的字段，找到对应页表项返回。  
> 按照mmu.h中的解释，虚拟地址32位，页目录项索引占去高10位，页表项索引占去中间10位，页内偏置占去低12位。
如图：
```
     +--------10------+-------10-------+---------12----------+
     | Page Directory |   Page Table   | Offset within Page  |
     |      Index     |     Index      |                     |
     +----------------+----------------+---------------------+
      \--- PDX(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/
      \----------- PPN(la) -----------/
```

[练习2.1] 请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处。

>1.页目录项：由页目录项基址寄存器和虚拟地址的高10位，找到页目录项，由页目录项中的值，结合页表项的索引，定出页表项。页目录项里有标志位，记录该页表项是否有效;脏页标志，记录是否被写过，在写回策略中决定是否要写回;访问控制位，决定用户能否访问。
页表项：由页目录项的基址，加上页表项的索引，定出线性地址。页表项里也有标志位，记录页表项是否有效;脏页标志，记录是否被写过，在写回策略中决定是否要写回内存;访问控制位，决定用户能否访问。

[练习2.2] 如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

> 发生页访问异常后，操作系统检查中断向量，硬件要转入页异常处理例称，相应的状态值被压入栈保存。如果发生的比如说是页缺失，就要从内存中载入块，更新页表项，然后异常处理返回，由程序再次访问内存，这次就能访问了。如果在页访问异常中再次出现了比如说页访问异常，就会触发double fault，导致系统崩溃，不得不reboot。

## [练习3] 释放某虚地址所在的页并取消对应二级页表项的映射

> 做法是每个页表结构里维护了一个字段ref，用来记录该页表被引用次数。如果页表项是有效的话，就将其转换成页表结构，然后减少它的ref，发现变成0,就表明这个页需要被释放回收了，并且在tlb里也将该页置为invalid

[练习3.1] 数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？

> 有对应关系。即Page结构里有ref字段，用来记录引用次数，如果是2,表明是页目录项;如果是1,表明是页表项。

[练习3.2] 如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？

> 如果虚拟地址和物理地址相等，就要建立一个恒等映射，将每个虚拟地址实际映射到同地址的物理地址。考虑本实验用的是二级页表，是段页式结构，所以通过设置访问权限标志位，来制止用户访问非法内存。所以，修改lab2,可能要改动pmm.c里的get_pte和page_remove_pte等函数。


## 二.实验分析

> 由于对实验中的代码不熟，尤其C语言编程就是可读性不好，我常常要grep，find来回查找相应的宏和内联函数，非常费事，而且对各个标志位的设置也不清楚。按照注释提醒一步步写完后，有时还是一直不对，所以之后参照答案来写，发现跟答案在大致步骤上仍是一致的。我不想用first-fit算法，至少用用最佳匹配也好，因为自己实现过，但是落到ucore实验中又不敢轻举妄动，因为不懂这些函数的调用关系，一旦改了结构，就调不出来。
> 不得不指出，虽然list.h中双向链表的实现非常巧妙，只是在基本list_entry_t中维护前后指针，然后利用to_struct可以转到包含字段实际结构中。但是，list.h中的链表删除没有对节点进行free，至少我现在还没看到，但又不敢改动，担心会崩溃。


## 三.OS原理知识

> 重要的知识点是：  
1.页表的分配算法，本实验中使用的是最先匹配的方法，还有最佳匹配等算法没有涉及实现。  
2.虚拟地址到物理地址的映射。  
3.多级页表的管理。

> ucore实验基本和原理一致，只是原理对一些实现进行了简化和抽象，比如其实页表项不只有一个标志位，真正实现还要理解页表项的实际组成结构，不然写不对。反正原理比较泛，真正实现起来，很多细节要注意。而且，我们是在已有代码上写，这样的开发还要求我们对已有代码理解，不然不能写对。


## 四.列出你认为OS原理中很重要，但在实验中没有对应上的知识点
> 基本都对应到了。



